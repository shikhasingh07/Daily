Backtracking Theme Summary

1. Subsets & Variations
- Core Idea: For each element â†’ choose or skip.
- Problems:
  - Subsets
  - Subsets II (handle duplicates â†’ sort + skip same num)
  - Sum of All Subsets XOR Total
  - Count Number of Maximum Bitwise-OR Subsets
  - The Number of Beautiful Subsets (extra constraints on subset validity)

Pattern:
function dfs(i, path) {
  if (i === nums.length) save(path);
  dfs(i+1, [...path, nums[i]]); // choose
  dfs(i+1, path);               // skip
}

2. Combinations & Permutations
- Core Idea: Explore all arrangements using recursion.
- Problems:
  - Combinations
  - Combination Sum
  - Combination Sum II (skip duplicates)
  - Permutations
  - Permutations II (skip duplicates)
  - Letter Tile Possibilities (similar, with dup handling)

Trick:
- Combination = increasing index (no reuse unless allowed).
- Permutation = track used[] to prevent reusing elements.

3. String Building / Parsing
- Core Idea: Build strings step by step, validate along the way.
- Problems:
  - Letter Combinations of a Phone Number
  - Palindrome Partitioning
  - Restore IP Addresses
  - The k-th Lexicographical String of All Happy Strings
  - Split String Into Descending Consecutive Values
  - Split String Into Max Unique Substrings
  - Maximum Length of Concatenated String With Unique Chars

4. Constraint Placement Problems
- Core Idea: Place numbers/objects in an array with rules.
- Problems:
  - Matchsticks to Square
  - Partition to K Equal Sum Subsets
  - Construct the Lexicographically Largest Valid Sequence

Trick:
- Greedy start with largest number first (for lexicographically largest).
- Use pruning: if a subset sum exceeds target, skip early.

5. Expression / Parentheses Building
- Core Idea: Try all recursive splits, combine results.
- Problems:
  - Different Ways to Add Parentheses

6. Special Problems
- Word Search (matrix path, mark visited)
- Construct Smallest Number from DI String (DFS with constraints)
- Find Unique Binary String (backtracking or greedy with set check)

Key Patterns to Remember
1. Choose / Skip (subsets)
2. Index progress with constraints (combinations, partitions)
3. Mark/Unmark (used[]) (permutations, tile possibilities)
4. Place/Undo (sequence placement, Matchsticks)
5. Split & Recurse (palindromes, IP restore, expressions)

Revision Checklist
- If I see a subset-like problem â†’ think choose/skip.
- If I see a string-splitting problem â†’ think split & recurse.
- If I see a placement problem â†’ think try largest first, prune early.
- Always: place â†’ recurse â†’ undo.



- Backtracking Heuristics & Generic Template
Quick mental checklist when facing a problem:

1. Am I deciding on each element in order?
   â†’ Use choose/skip recursion (no loop needed).
   Example: Subsets, Subsets II, XOR subsets.

2. Am I building a sequence where each step can come from many options?
   â†’ Use a for loop inside recursion.
   Example: Permutations, Combination Sum, N-Queens, Word Search.

3. Do I need to skip duplicates?
   â†’ Sort first + add condition:
   if (i > start && nums[i] === nums[i-1]) continue;
   Example: Combination Sum II, Permutations II.


ðŸ§© Generic Backtracking with Constraints Template

function backtrack(idx, path) {
    // Base case
    if (idx === targetLength) {
        if (constraintsSatisfied(path)) {
            results.push([...path]);  // or return true if only one solution needed
        }
        return;
    }

    // Explore choices
    for (let choice of possibleChoices) {
        if (violatesConstraints(choice, path)) continue; // prune early

        // Make choice
        path.push(choice);  // OR mark used[choice] = true

        // Recurse
        backtrack(idx + 1, path);

        // Undo choice (backtrack)
        path.pop();         // OR used[choice] = false
    }
}

ðŸŒŸ Key Notes
- Choose/Skip â†’ when each element has exactly 2 options (include or not).
- For-loop recursion â†’ when each step has multiple branching options.
- Skip duplicates â†’ sort + condition (i > start && nums[i] === nums[i-1]).
- Backtracking = Place â†’ Recurse â†’ Undo.
- Constraints go in the if-checks before recursing.
