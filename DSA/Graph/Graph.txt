
/*
Time Complexity - 0(V+E)(vertice and no of edges)
*/
/*
 BFs - shortest path in undirected graph
*/
class Graph{
        int V;
        ArrayList<Integer>[] list;
        public Graph(int v){
            V = v;
            list = new ArrayList[v];
            for(int i = 0; i < v; i++){
                list[i] = new ArrayList<>();
            }
        }
        void addEdge(int i, int j, boolean unDirected){
            list[i].add(j);
            if(unDirected)
                list[j].add(i);
        }
void Bfs(int source ,set<<Integer>>){
 Queue<Integer> q = new LinkedList<>();
    Boolean[] visited = new Boolean[V];
    Arrays.fill(visited, false);
     q.push(source); 
     visited[source] == true; 
 while(!q.empty()){
    int f = q.front(); 
    q.pop(); 
   
   for(int nbr : l[f]){
    if(visited[f] !== true){
        visited[f] == true; 
        q.push(f); 
    }
   }
 }  
}

// shortest path - in undirected graph
void Bfs(int source ,set<<Integer>>){
queue<int> q ; 
visited[] array = new Array[bool]; 
distence[] array = new Array[int]; 
parent[] array = 
     q.push(source); 
     visited[source] == true; 
 while(!q.empty()){
    int f = q.front(); 
    q.pop(); 
   
   for(int nbr : l[f]){
    if(visited[f] !== true){
        visited[f] == true; 
        distence[f] += 1; 
        q.push(f); 
    }
   }
 }  
}
}

public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {
        Queue<TreeNode> qu = new LinkedList<>(); 
        qu(cloned)
        int value = target.val; 
        while(!cloned.isEmpty()){
            TreeNode node = qu.pop(); 
            if(value == node.val){
                return node; 
            }
        }
}

Message Route
There is a network of n computers, each computer is numbered 1 to n.
The computer network is given as an array of edges where edges[i] = [ui, vi] is a bidirectional edge that connects computer ui and computer vi .
//using BFS 
messageRoute 
int messageRoute(int n, int end , vector<vector<int>>edges )
{
          Queue<Integer> qu = new LinkedList<>();
        boolean[] visited = new boolean[n + 1];
        int[] parent = new int[n + 1];
        int[] distance = new int[n + 1];
        Arrays.fill(distance, Integer.MAX_VALUE);
        Arrays.fill(parent, -1);
        int start = 1;  // Assuming the start node is 1
        qu.offer(start);
        visited[start] = true;
        distance[start] = 0;
        while (!qu.isEmpty()) {
            int node = qu.poll();
            for (int neighbor : edges.get(node)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    distance[neighbor] = distance[node] + 1;
                    parent[neighbor] = node;
                    qu.offer(neighbor);
                }
            }
        }
        if (distance[end] == Integer.MAX_VALUE) {
            System.out.println("No path found from " + start + " to " + end);
        } else {
            System.out.print("Path from " + start + " to " + end + ": ");
            int temp = end;
            while (temp != start) {
                System.out.print(temp + " <-- ");
                temp = parent[temp];
            }
            System.out.println(start);
            System.out.println("Shortest path length: " + distance[end]);
        }
}


/*-------------------------DFS------------------------------------*/
//using stack 
boolean[] seen = new boolean[rooms.size()]; 
seen[0] = true
stack<Integer> stack = new Stack(); 
stack.push(0); 
while(!stack.isNotEmapty()){
    int node = stack.pop();
        for (int nei: rooms.get(node)) // For every key in room # 'node'...
                if (!seen[nei]) { // ...that hasn't been used yet
                    seen[nei] = true; // mark that we've entered the room
                    stack.push(nei); // add the key to the todo list
                }
        }
        for (boolean v: seen)  // if any room hasn't been visited, return false
            if (!v) return false;
        return true;
    


//Recurive 
helper(TreeNode node , bool[] visited){
      visited[node] = true; 
      for(int nbr : l[node]){
        if(!visited[nbr]){
            helper(nbr,visited);
        }
      }
}
void dfs(int source){
 bool[] visited = new bool[V][0]; 
 dfs helper(nbr,visited);
}


/* --------------Cycle Detetcion---------------------------*/
cycle detction 
in undirected Graph 
void dfs(int node, boolean[] visited , parent){
  
  visited[node] = true; 
  for(auto nbr : l[node]){
    if(!visited[nbr]){
        bool nbrfoundCycle = dfs(nbr,visited,node);
        if(nbrfoundCycle){
            return true
        }
        else (nbr!= parent){
            return true; 
        }
    }
    return false; 
  }
}
bool contain_cycle(){
    Boolean [] bool = new Boolean[v.length]; 
    return dfs(starting->0,visited,-1->parent); 
}

cycle detction 
in directed Graph 
void dfs(Boolean[] visited,Stack<Integer> st,int i){
visited[i] = true; 
stack.push(i);
    //Backedge 
    for(int nbr : adj.get(i)){
        if (st.contains(nbr)) {
           return true;  // Cycle detected
       } 
       // If the neighbor has not been visited, we recursively visit it
       else if (!visited[nbr]) {
           if (dfs(nbr, adj, visited, st)) {
               return true;  // Cycle detected in recursion
           }
       }
   }
   st.pop();
   return false;
}
void directed(){
    Boolean[] visited = new Boolean[]; 
    Stack<Integer> st = new Stack(); 
   for(int i : v){
     if(!visited[i]) {
       if( dfs(st , visited,i)) {
        return false; 
       }
     }
   }
   return true; 
}
Question - 
207. Course Schedule
class Solution {
    public boolean dfs(int i , List<List<Integer>> adj , boolean[] visited , Stack st){
        visited[i] = true; 
        st.push(i); 
        for(int nbr : adj.get(i)){
             if (st.contains(nbr)) {
                return true;  // Cycle detected
            } 
            // If the neighbor has not been visited, we recursively visit it
            else if (!visited[nbr]) {
                if (dfs(nbr, adj, visited, st)) {
                    return true;  // Cycle detected in recursion
                }
            }
        }
        st.pop();
        return false;
    }
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> adj = new ArrayList<>(numCourses);
        for (int i = 0; i < numCourses; i++) {
            adj.add(new ArrayList<>());
        }
        for (int[] prerequisite : prerequisites) {
            adj.get(prerequisite[1]).add(prerequisite[0]);
        }
        boolean[] visited = new boolean[numCourses];
        Stack<Integer> st = new Stack();
        for (int i = 0; i < numCourses; i++) {
            if (!visited[i]) {
                if (dfs(i, adj, visited, st)) {
                    return false;
                }
            }
        }
        return true;
    }
}


Bipartite Graph 
 - you can divide all vertices of graph in 2 sets 
 - such that all edges of the graph are from set1 to set2 
 this is example [true]
 1-2,3 
 2-4 
 3-4
 4 -2,3
 example - [not true] [because graph 1 is connented with 5]
 Cycle is detected
 odd number of nodes 
 1-2
 2-3
 3-4
 4-5
 5-1

Void dfs(int I , int V , adj , int color[]){
 queue<int> a; 
q.queue(start); 
Color[i] = 0; 
  while(!q.empty()){
   int node = q.poll; 
    q.pop(); 
If (auto it : adj[q]){
   if(color[it] == -1){
     color[it] = !color[node]; 
    q.push(it); 
  else if(color[it] == color[node])  {
Return false; 
    }
     }
   }  
}
}
Void isBiprate( ){
   int color[V]; 
  for(int I =0 ; I < V ; i++) color[i] = -1; 
  for(int I = 0 ; I < v;i++){
   if(color[i] == -1){
    if(check(I , V ,adj , color) == false){
        return false;   
     }
    }
  }
}
